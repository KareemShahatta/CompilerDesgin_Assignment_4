package visitor;import syntaxtree.*;import symboltable.*;import javax.lang.model.type.IntersectionType;public class TypeCheckExpVisitor extends TypeDepthFirstVisitor {    public ErrorMsg error = new ErrorMsg();        // @TODO: Notice this method is added    // Exp e1,e2;    public Type visit(Or n) {        if (!(n.e1.accept(this) instanceof BooleanType))        {            error.complain("Left side of Or must be of type integer");        }        if (!(n.e2.accept(this) instanceof BooleanType))        {            error.complain("Right side of Or must be of type integer");        }        return new BooleanType();    }    // @TODO: Notice this method is added    // Exp e1,e2;    public Type visit(Equals n) {        if (!(n.e1.accept(this) instanceof IntegerType))        {            error.complain("Left side of Equal must be of type integer");        }        if (!(n.e2.accept(this) instanceof IntegerType))        {            error.complain("Right side of Equal must be of type integer");        }        return new BooleanType();    }    // @TODO: Notice this method is modified and system.exit() call commented off    // Exp e1,e2;    public Type visit(LessThan n) {        if (!(n.e1.accept(this) instanceof IntegerType))        {            error.complain("Left side of LessThan must be of type integer");        }        if (!(n.e2.accept(this) instanceof IntegerType))        {            error.complain("Right side of LessThan must be of type integer");        }        return new BooleanType();    }    // Exp e1,e2;    public Type visit(Plus n) {        if (!(n.e1.accept(this) instanceof IntegerType))        {            error.complain("Left side of LessThan must be of type integer");        }        if (!(n.e2.accept(this) instanceof IntegerType))        {            error.complain("Right side of LessThan must be of type integer");        }        return new IntegerType();    }    // Exp e1,e2;    public Type visit(Minus n) {        if (!(n.e1.accept(this) instanceof IntegerType))        {            error.complain("Left side of LessThan must be of type integer");        }        if (!(n.e2.accept(this) instanceof IntegerType))        {            error.complain("Right side of LessThan must be of type integer");        }        return new IntegerType();    }    // Exp e1,e2;    public Type visit(Times n) {        if (!(n.e1.accept(this) instanceof IntegerType))        {            error.complain("Left side of LessThan must be of type integer");        }        if (!(n.e2.accept(this) instanceof IntegerType))        {            error.complain("Right side of LessThan must be of type integer");        }        return new IntegerType();    }    // Exp e1,e2;    public Type visit(ArrayLookup n) {        if (!(n.e1.accept(this) instanceof IntArrayType))        {            error.complain("Left side of LessThan must be of type integer");        }        if (!(n.e2.accept(this) instanceof IntegerType))        {            error.complain("Right side of LessThan must be of type integer");        }        return new IntegerType();    }    // Exp e;    public Type visit(ArrayLength n) {        if (!(n.e.accept(this) instanceof IntArrayType))        {            error.complain("Left side of LessThan must be of type integer");        }        return new IntegerType();    }    // @TODO: Notice this method is modified and system.exit() call commented off    // Exp e;    // Identifier i;    // ExpList el;    @Override    public Type visit(Call n)    {        if (!(n.e.accept(this) instanceof IdentifierType))        {            error.complain("method " + n.i.toString()                    + "called  on something that is not a"                    + " class or Object.");        }        String mname = n.i.toString();        String cname = ((IdentifierType) n.e.accept(this)).s;        RamMethod calledMethod = TypeCheckVisitor.symbolTable.getMethod(mname, cname);        if(calledMethod != null)        {            for (int i = 0; i < n.el.size(); i++) {                Type t1 = null;                Type t2 = null;                if (calledMethod.getParamAt(i) != null) {                    t1 = calledMethod.getParamAt(i).type();                }                t2 = n.el.elementAt(i).accept(this);                if (!TypeCheckVisitor.symbolTable.compareTypes(t1, t2))                {                    error.complain("Type Error in arguments passed to "                            + cname + "." + mname);                }            }        }        return TypeCheckVisitor.symbolTable.getMethodType(mname, cname);    }    // int i;    public Type visit(IntegerLiteral n) {        return new IntegerType();    }    public Type visit(True n) {        return new BooleanType();    }    public Type visit(False n) {        return new BooleanType();    }    // String s;    public Type visit(IdentifierExp n) {        return TypeCheckVisitor.symbolTable.getVarType(TypeCheckVisitor.currMethod,                TypeCheckVisitor.currClass, n.s);    }    public Type visit(This n) {        return TypeCheckVisitor.currClass.type();    }    // Exp e;    public Type visit(NewArray n) {        if (!(n.e.accept(this) instanceof IntegerType))        {            error.complain("Left side of LessThan must be of type integer");        }        return new IntArrayType();    }    // Identifier i;    public Type visit(NewObject n) {        return new IdentifierType(n.i.s);    }    // Exp e;    public Type visit(Not n) {        if (!(n.e.accept(this) instanceof BooleanType))        {            error.complain("Left side of LessThan must be of type integer");        }        return new BooleanType();    }}//TypeCheckVisitor.