# Programming Assignment 4: Semantic Analysis

-----

### Date Out: Tuesday, November 7
### Due Date: Tuesday, November 21 (end of day, before you leave for Thanksgiving break!)

-----

## Introduction

In this programming assignment, we will build our compiler's semantic analyzer. First, we will construct a symbol table, and then we will perform type checking. The semantic analyzer will be the last component of the compiler's frontend, and our final opportunity to catch errors before we proceed into generating machine-level code.

The construction of the symbol table and the type checking will be implemented using visitors that traverse the abstract syntax tree, which is created by the semantic actions in the parser's `.jj` grammar specification.

As starter code, I give you an almost complete JavaCC grammar file that contains the grammar for our Ram23 language, augmented with semantic actions that are called from the automatically generated parser to build an abstract syntax tree (AST) during the recursive descent parsing process

By providing this full grammar, everyone is beginning from a 100% correct starting point. This grammar is modified in the following ways compared to your Programming Assignment #3 to:

  1. adhere to Java precedence rules
  1. include semantic actions so that the JavaCC parser generator also builds abstract syntax trees
  1. implement *most* of our Ram23 additional language features

```
MyCompilerProject
  - src/main/java/compilers/Ram23Compiler.java        (driver)
  - src/main/javacc/RamSemantic.jj                    (mostly complete grammar for Ram23 with semantic actions)
  - src/main/symboltable/Table.java                   (symbol table data structure)
  - src/main/symboltable/RamMethod.java
  - src/main/symboltable/RamClass.java
  - src/main/symboltable/RamVariable.java
  - src/main/visitors/TypeVisitor.java                (similar to Visitor)
  - src/main/visitors/DepthFirstVisitor.java          (implements Visitor)
  - src/main/visitors/TypeDepthFirstVisitor.java      (implements TypeVisitor)
  - src/main/visitors/BuildSymbolTableVisitor.java    (extends TypeDepthFirstVisitor)
  - src/main/visitors/TypeCheckVisitor.java           (extends TypeDepthFirstVisitor)
  - src/main/syntaxtree/*                             (updated syntaxtree classes)
```

## The Tasks

### Task 1:

Familiarize yourself with these new files:

* `SymbolTable.java` contains a data structure that supports a symbol table and the operations that we would like to be able to perform on it.
* `TypeVisitor.java` is just like `Visitor.java` (introduced in lecture), except that it defines all `visit` methods as returning a `Type` rather than `void`.
* All of the files in the `syntaxtree` package are now updated to contain an additional `visit` method; they now look like this:

```java
  public void accept(Visitor v) {
    v.visit(this);
  }

  public Type accept(TypeVisitor v) {
    return v.visit(this);
  }
```

`TypeDepthFirstVisitor.java` is a naive visitor that simply visits every node in an AST in a depth-first manner (as opposed to breadth-first), and returns its `Type`. By itself, it is unable to do anything constructive. However, its usefulness is that it can be _extended_ (like it is by `BuildSymbolTable.java` and `TypeCheckVisitor.java` ) where these visitors only have to implement methods on the nodes relevant to its task, and the non-interesting methods remain handled by `TypeDepthFirstVisitor.java` .

Be sure that you understand this class hierarchy. Consider the `visit(Plus n)` method. Does it make sense that it:

- is naively defined in `TypeDepthFirstVisitor.java`, because it implements `Visitor.java`
- and overwritten in `TypeCheckVisitor.java`, as it extends `TypeDepthFirstVisitor.java`
- yet not defined in `BuildSymbolTableVisitor.java`

### Task 2:

Clone your starting repository that contains these new files. Use the `compilers/Ram23Compiler.java` as the driver for building the symbol table and performing the semantic analysis. 
Use the `Maven` project workflow of (just like the last project) : 

1. `mvn clean` -- will erase everything from the `target` directory in your project, including any generated `.class` files and `.java` source files generated by `JavaCC`
2. `mvn javacc:javacc` -- runs JavaCC against your grammar, automatically creating `.java` files that are placed in the `target/generated-sources/javacc/compilers/` directory. **Whenever you edit/modify the `.jj` file, you need to re-generate the scanner by executing this step.**
3. running the `compilers.Ram23Compiler` driver -- tests your front end against a single `.ram23` program

### Task 3:

Note that I've already given you the symbol table visitor `visitor/BuildSymbolTableVisitor.java`. 
It is called in the driver `compilers/Ram23Compiler.java` on lines 32-33. 
However, before using it, you have to complete the symbol table data structure below. (Also note that line 38 of the driver calls the `.toString` method of the symbol table `symboltable/Table.java`.

### Task 4, Symbol Table Data Structure:

Extend the data structure for methods and variables. 
Define a `symboltable.RamMethod` and `symboltable.RamVariable` class. 
I already give you `symboltable.Table` and `symboltable.RamClass`. Here is my interface for these two classes (for brevity I am not including a JavaDoc). 
Please ask me/post on Discord if you would like clarification about the functionality of any of these methods.

```
RamMethod.java
--------------
RamMethod(String, Type) : constructor
boolean addParam(String, Type)
boolean addVar(String, Type)
boolean containsParam(String)
boolean containsVar(String)
String getId()
RamVariable getParam(String)
RamVariable getParamAt(int)
Iterator getParams()
RamVariable getVar(String)
String toString()
Type type()

RamVariable.java
----------------
RamVariable(String, Type) : constructor
String getId()
Type type()
String toString()
```

### Task 5, Symbol Table Printer

Create additional `toString()` methods for each class in the `symboltable` package as necessary so that the entire symbol table can be printed out after it is constructed. 
Here is my output for the `test_programs/pass/LinearSearch.ram23` file:

```
Classes:
    LS
        Fields:
            class syntaxtree.IntegerType size
            class syntaxtree.IntArrayType number
        Methods:
            class syntaxtree.IntegerType Search
                Params:
                    class syntaxtree.IntegerType num
                Locals:
                    class syntaxtree.IntegerType ifound
                    class syntaxtree.IntegerType j
                    class syntaxtree.IntegerType nt
                    class syntaxtree.IntegerType aux02
                    class syntaxtree.IntegerType aux01
                    class syntaxtree.IdentifierType ls01
            class syntaxtree.IntegerType Start
                Params:
                    class syntaxtree.IntegerType sz
                Locals:
                    class syntaxtree.IntegerType aux02
                    class syntaxtree.IntegerType aux01
            class syntaxtree.IntegerType Init
                Params:
                    class syntaxtree.IntegerType sz
                Locals:
                    class syntaxtree.IntegerType k
                    class syntaxtree.IntegerType j
                    class syntaxtree.IntegerType aux02
                    class syntaxtree.IntegerType aux01
            class syntaxtree.IntegerType Print
                Params:
                Locals:
                    class syntaxtree.IntegerType j
    LinearSearch
        Fields:
        Methods:
            class syntaxtree.IdentifierType main
                Params:
                    class syntaxtree.IdentifierType args
                Locals:
```

### Task 6, Type Checker:

Extend my starter code `visitor/TypeCheckVisitor.java` and`visitor/TypeCheckExpVisitor.java` to perform type checking. What type checking is already implemented? What is missing?

1. Originally, you should receive the following error: "Type error in assignment to ls01". Why? What needs to be fixed?
2. Revise the code so that it incorporates the `symboltable.ErrorMsg` class (found in your class notes from the "Type Checking" lecture), and continues to type check the entire program rather than aborting using `System.exit`. (The main driver `driver.Ram23Compiler` uses a conditional on line 44 to check whether any error was identified.) Also do the same for the symbol table builder.

### Task 7

Don't forget to extend MiniJava for any features defined in our Ram13 language specification.

### Task 8

Use `mvn test` to your front end against multiple test cases in batch.

### Ram23 Resources

Links to the MiniJava and Ram23 Specification are in the starter code repo.

## CSC416 vs CSC565

Additional work for **CSC565 students only**:

1. Add three pass tests (`.ram23` files) and three fail tests to the `test_programs` folder. You'll also need to modify the `PassTest.java` and `FailTest.java` test suites.
1. Continue your extension of this project to also handle the `for` repetition structure.

## Submission instructions

Push your completed Java Maven project to your GitHub. Verify the success of the autograding GitHub Action.